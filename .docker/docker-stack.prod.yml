x-common-deploy: &common-deploy
  update_config:
    order: start-first
    failure_action: rollback
  restart_policy:
    condition: any

x-common-placement: &common-placement
  placement:
    constraints:
      - node.role == manager

x-common-healthcheck: &common-healthcheck
  interval: 10s
  timeout: 5s
  retries: 3
  start_period: 30s

x-common-logging: &common-logging
  driver: json-file
  options:
    max-size: 10m
    max-file: 3

x-backend-config: &backend-config
  image: ghcr.io/feedstand/backend:${VERSION_TAG:-latest}
  depends_on:
    - pgbouncer
    - database

x-backend-environment: &backend-environment
  SERVER_HOST: ${BACKEND_SERVER_HOST}
  SERVER_PORT: ${BACKEND_SERVER_PORT}
  DATABASE_HOST: ${BACKEND_DATABASE_HOST}
  DATABASE_PORT: ${BACKEND_DATABASE_PORT}
  DATABASE_NAME: ${BACKEND_DATABASE_NAME}
  DATABASE_USER: ${BACKEND_DATABASE_USER}
  DATABASE_PASS: ${BACKEND_DATABASE_PASS}
  QUEUE_HOST: ${BACKEND_QUEUE_HOST}
  QUEUE_PORT: ${BACKEND_QUEUE_PORT}
  SENTRY_DSN: ${BACKEND_SENTRY_DSN}
  SENTRY_ENV: ${BACKEND_SENTRY_ENV}

services:
  traefik:
    image: traefik:3
    environment:
      - CLOUDFLARE_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
    command:
      # Global
      - --global.sendAnonymousUsage=true
      # Swarm Provider
      - --providers.docker=false
      - --providers.swarm=true
      - --providers.swarm.exposedbydefault=false
      # - --providers.swarm.network=feedstand_public
      # Entrypoints
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      # Global HTTP → HTTPS Redirect
      - --entrypoints.web.http.redirections.entrypoint.to=websecure
      - --entrypoints.web.http.redirections.entrypoint.scheme=https
      - --entrypoints.web.http.redirections.entrypoint.permanent=true
      # Let's Encrypt with DNS Challenge (Cloudflare)
      - --certificatesresolvers.letsencrypt.acme.dnschallenge=true
      - --certificatesresolvers.letsencrypt.acme.dnschallenge.provider=cloudflare
      - --certificatesresolvers.letsencrypt.acme.email=${TRAEFIK_ACME_EMAIL}
      - --certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json
      # Logging
      - --log.level=INFO
      - --accesslog.filepath=/logs/access.log
      - --accesslog.bufferingsize=100
    deploy:
      <<: [*common-deploy, *common-placement]
      update_config:
        # Host-mode ports require stop-first to release ports before starting new container
        order: stop-first
        failure_action: rollback
      labels:
        traefik.enable: "true"
        # Dummy port to satisfy Traefik service discovery
        traefik.http.services.traefik-dummy.loadbalancer.server.port: "9999"
        # Replaces: Cloudflare HSTS, Automatic HTTPS Rewrites
        traefik.http.middlewares.shared-security.headers.stsSeconds: "31536000"
        traefik.http.middlewares.shared-security.headers.stsIncludeSubdomains: "true"
        traefik.http.middlewares.shared-security.headers.stsPreload: "true"
        traefik.http.middlewares.shared-security.headers.forceSTSHeader: "true"
        traefik.http.middlewares.shared-security.headers.contentSecurityPolicy: "upgrade-insecure-requests"
        traefik.http.middlewares.shared-security.headers.frameDeny: "true"
        traefik.http.middlewares.shared-security.headers.contentTypeNosniff: "true"
        traefik.http.middlewares.shared-security.headers.referrerPolicy: "strict-origin-when-cross-origin"
        traefik.http.middlewares.shared-security.headers.customResponseHeaders.server: ""
        # Enable GZIP Compression
        traefik.http.middlewares.compression.compress: "true"
        # HTTP Basic Auth for private services
        traefik.http.middlewares.basic-auth.basicauth.users: "${TRAEFIK_BASIC_AUTH}"
    ports:
      - target: 80
        published: 80
        protocol: tcp
        mode: host
      - target: 443
        published: 443
        protocol: tcp
        mode: host
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - letsencrypt_data:/letsencrypt
    # networks:
    #   - public
    logging:
      <<: *common-logging

  dozzle:
    image: amir20/dozzle:latest
    environment:
      DOZZLE_MODE: swarm
      DOZZLE_LEVEL: info
      DOZZLE_TAILSIZE: 300
    deploy:
      <<: *common-deploy
      mode: global
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M
      labels:
        traefik.enable: "true"
        traefik.http.routers.dozzle.rule: "Host(`logs.feedstand.com`)"
        traefik.http.routers.dozzle.entrypoints: "websecure"
        traefik.http.routers.dozzle.tls: "true"
        traefik.http.routers.dozzle.tls.certresolver: "letsencrypt"
        traefik.http.routers.dozzle.middlewares: "basic-auth@swarm,shared-security@swarm"
        traefik.http.services.dozzle.loadbalancer.server.port: "8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    # networks:
    #   - public
    logging:
      <<: *common-logging

  frontend:
    image: ghcr.io/feedstand/frontend:${VERSION_TAG:-latest}
    environment:
      API_URL: ${FRONTEND_API_URL}
      SENTRY_DSN: ${FRONTEND_SENTRY_DSN}
      SENTRY_ENV: ${FRONTEND_SENTRY_ENV}
    deploy:
      <<: [*common-deploy, *common-placement]
      labels:
        traefik.enable: "true"
        traefik.http.routers.frontend.rule: "Host(`app.feedstand.com`)"
        traefik.http.routers.frontend.entrypoints: "websecure"
        traefik.http.routers.frontend.tls: "true"
        traefik.http.routers.frontend.tls.certresolver: "letsencrypt"
        traefik.http.routers.frontend.middlewares: "shared-security@swarm"
        traefik.http.services.frontend.loadbalancer.server.port: "4000"
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "wget", "-q", "--spider", "http://0.0.0.0:4000/health"]
    # networks:
    #   - public
    logging:
      <<: *common-logging

  backend-server:
    <<: *backend-config
    environment:
      <<: *backend-environment
      FEATURE_MIGRATOR: "true"
      FEATURE_SERVER: "true"
    deploy:
      <<: [*common-deploy, *common-placement]
      labels:
        traefik.enable: "true"
        traefik.http.routers.backend.rule: "Host(`api.feedstand.com`)"
        traefik.http.routers.backend.entrypoints: "websecure"
        traefik.http.routers.backend.tls: "true"
        traefik.http.routers.backend.tls.certresolver: "letsencrypt"
        traefik.http.routers.backend.middlewares: "shared-security@swarm"
        traefik.http.services.backend.loadbalancer.server.port: "4001"
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "wget", "-q", "--spider", "http://0.0.0.0:4001"]
    # networks:
    #   - public
    #   - internal
    logging:
      <<: *common-logging

  backend-worker:
    <<: *backend-config
    environment:
      <<: *backend-environment
      FEATURE_WORKER: "true"
      # Set heap to 76% of container memory (450M × 0.76 = 342M)
      NODE_OPTIONS: "--max-old-space-size=342"
    deploy:
      <<: *common-deploy
      replicas: 40
      resources:
        # limits:
        #   cpus: '1.0'
        #   memory: 450M
        reservations:
          cpus: '0.25'
          memory: 200M
      update_config:
        parallelism: 4
        delay: 30s
        order: start-first
      placement:
        # max_replicas_per_node: 10
        constraints:
          - node.role != manager
          - node.labels.worker == true
        preferences:
          - spread: node.id
    # networks:
    #   - internal
    logging:
      <<: *common-logging

  pgbouncer:
    image: edoburu/pgbouncer
    environment:
      DB_HOST: database
      DB_NAME: ${BACKEND_DATABASE_NAME}
      DB_USER: ${BACKEND_DATABASE_USER}
      DB_PASSWORD: ${BACKEND_DATABASE_PASS}
      POOL_MODE: transaction
      MAX_CLIENT_CONN: 500
      DEFAULT_POOL_SIZE: 50
      MAX_DB_CONNECTIONS: 100
      RESERVE_POOL_SIZE: 25
      RESERVE_POOL_TIMEOUT: 5
      ADMIN_USERS: ${BACKEND_DATABASE_USER}
      AUTH_TYPE: scram-sha-256
    deploy:
      <<: [*common-deploy, *common-placement]
      # endpoint_mode: dnsrr
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "pg_isready", "-h", "localhost"]
    depends_on:
      - database
    # networks:
    #   - public
    #   - internal
    logging:
      <<: *common-logging

  database:
    image: postgres:18-alpine
    ports:
      - target: 5432
        published: 5432
        mode: host
    environment:
      POSTGRES_DB: ${BACKEND_DATABASE_NAME}
      POSTGRES_USER: ${BACKEND_DATABASE_USER}
      POSTGRES_PASSWORD: ${BACKEND_DATABASE_PASS}
    deploy:
      <<: [*common-deploy, *common-placement]
    volumes:
      - database_data:/var/lib/postgresql/data
    # networks:
    #   - internal
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "pg_isready", "-h", "localhost"]
    logging:
      <<: *common-logging

  bullboard:
    image: venatum/bull-board:latest
    environment:
      REDIS_HOST: ${BACKEND_QUEUE_HOST}
      REDIS_PORT: ${BACKEND_QUEUE_PORT}
      BULL_PREFIX: bull
      BULL_VERSION: BULLMQ
    deploy:
      <<: [*common-deploy, *common-placement]
      labels:
        traefik.enable: "true"
        traefik.http.routers.bullboard.rule: "Host(`queues.feedstand.com`)"
        traefik.http.routers.bullboard.entrypoints: "websecure"
        traefik.http.routers.bullboard.tls: "true"
        traefik.http.routers.bullboard.tls.certresolver: "letsencrypt"
        traefik.http.routers.bullboard.middlewares: "basic-auth@swarm,shared-security@swarm"
        traefik.http.services.bullboard.loadbalancer.server.port: "3000"
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "wget", "-q", "--spider", "http://0.0.0.0:3000"]
    logging:
      <<: *common-logging

  scalar:
    image: scalarapi/api-reference:latest
    environment:
      API_REFERENCE_CONFIG: '{"sources":[{"url":"https://api.feedstand.com/openapi.json"}]}'
    deploy:
      <<: [*common-deploy, *common-placement]
      labels:
        traefik.enable: "true"
        traefik.http.routers.scalar.rule: "Host(`docs.feedstand.com`)"
        traefik.http.routers.scalar.entrypoints: "websecure"
        traefik.http.routers.scalar.tls: "true"
        traefik.http.routers.scalar.tls.certresolver: "letsencrypt"
        traefik.http.routers.scalar.middlewares: "basic-auth@swarm,shared-security@swarm"
        traefik.http.services.scalar.loadbalancer.server.port: "8080"
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "wget", "-q", "--spider", "http://0.0.0.0:8080/health"]
    logging:
      <<: *common-logging

  queue:
    image: redis:8-alpine
    command:
      - "redis-server"
      - "--save ''"
      - "--appendonly yes"
      - "--appendfsync everysec"
      - "--no-appendfsync-on-rewrite yes"
      - "--auto-aof-rewrite-percentage 100"
      - "--auto-aof-rewrite-min-size 256mb"
      - "--aof-rewrite-incremental-fsync yes"
      - "--maxmemory-policy noeviction"
      - "--aof-use-rdb-preamble yes"
    deploy:
      <<: [*common-deploy, *common-placement]
    volumes:
      - queue_data:/data
    # networks:
    #   - internal
    healthcheck:
      <<: *common-healthcheck
      test: ["CMD", "redis-cli", "ping"]
    logging:
      <<: *common-logging

volumes:
  letsencrypt_data:
  database_data:
  queue_data:

# networks:
#   public:
#     driver: overlay
#     attachable: true
#   internal:
#     driver: overlay
#     internal: true
